---
group: "Minimax"
icon: "pi-shield"
---

# Game Rules, Captures, and Serving

## Capture Detection

A capture occurs when placing a stone creates a sandwich pattern: `P-OO-P` in any of 8 directions — the player's stone bookends two consecutive opponent stones. The engine checks this using bitmask operations: for each direction, verify that the two intermediate cells contain opponent stones and the far cell contains the player's stone.

When captures are found, the two middle opponent stones are removed from the board and the capturing player's score increments. Capturing 5 pairs (10 stones total) is an alternative win condition.

## Double-Three Detection

A move is **forbidden** if it simultaneously creates two or more "open threes" — three consecutive stones with open ends on both sides. This is the Renju-style restriction that prevents trivially forced wins.

The detection uses `CForbiddenPointFinder`, sourced from [renju.se open source](https://www.renju.se/renlib/opensrc/), as a direction-based implementation for double-three validation.

```cpp
// minimax/src/gomoku/forbidden/ForbiddenPointFinder.cpp:1037-1052
bool CForbiddenPointFinder::IsDoubleThree(int x, int y) {
  if (cBoard[x + 1][y + 1] != EMPTYSTONE) return false;

  if (IsFive(x, y, 0))  // five overrides double-three
    return false;

  int nThree = 0;
  for (int i = 1; i <= 4; i++) {
    if (IsOpenThree(x, y, 0, i)) nThree++;
  }

  if (nThree >= 2)
    return true;
  else
    return false;
}
```

An important optimization for search: double-three is checked **per candidate move only**, not as a full board scan. During move generation, `shouldIncludeMove` calls the detection for each specific position:

```cpp
// minimax/src/gomoku/search/Minimax.cpp:77-83
inline bool shouldIncludeMove(Board *board, int col, int row, int player,
                              bool enableDoubleThreeRestriction) {
  if (!enableDoubleThreeRestriction) return true;
  if (!Rules::detectDoublethree(*board, col, row, player)) return true;

  return Rules::detectCaptureStonesNotStore(*board, col, row, player);
}
```

The last line handles an important exception: if a double-three move **also captures stones**, it's allowed — the capture resolves the forbidden state. The full-board `FindForbiddenPoints()` method exists but is only used for game state display on the frontend, never during search.

The board state is reconstructed for the finder on each check by mapping bitboard positions to the finder's internal representation:

```cpp
// minimax/src/gomoku/core/Rules.cpp:66-82
bool Rules::detectDoublethree(Board& board, int x, int y, int player) {
  CForbiddenPointFinder finder(BOARD_SIZE);

  for (int row = 0; row < BOARD_SIZE; ++row) {
    for (int col = 0; col < BOARD_SIZE; ++col) {
      int cell = board.getValueBit(col, row);
      if (cell == EMPTY_SPACE) continue;
      if (cell == player) {
        finder.SetStone(col, row, BLACKSTONE);
      } else {
        finder.SetStone(col, row, WHITESTONE);
      }
    }
  }

  return finder.IsDoubleThree(x, y);
}
```

## What Worked and What Didn’t

I initially used bitmask pattern matching on bitboards for double-three validation. It was fast, but incorrect in recursive open-three edge cases (an open three can itself become invalid depending on follow-up constraints), which surfaced during AlphaZero cross-checking.

I replaced rule validation with `CForbiddenPointFinder` from [renju.se](https://www.renju.se/renlib/opensrc/) (see [Game Rules](/docs/about-gomoku/basic-rules)), while keeping bitmask-based evaluation where it is both correct and fast. The key lesson was to separate correctness-critical rule logic from performance-oriented scoring logic and apply each method where it fits.

## Win Condition

The game ends when either player achieves 5+ stones in a row (gomoku) or captures 5 pairs (10 stones). In the evaluation, a gomoku line that contains stones vulnerable to capture is scored lower ("breakable gomoku") — the opponent might be able to break the line by capturing stones within it before the win is confirmed.

## WebSocket Server

The minimax engine runs as a libwebsockets server on port 8005. The server is **stateless per request**: the entire board state is sent in the JSON payload each time — no session state is maintained between moves.

On startup, the server initializes Zobrist keys and pre-computes both evaluation lookup tables ($2 \times 262{,}144$ entries). At request time: parse JSON → construct Board from the payload → select search algorithm by difficulty → run search → return the AI move, updated board, captured stones, evaluation scores, and execution time.

The WebSocket protocol specification is documented in the [About Gomoku](/docs/about-gomoku/intro) section — both the minimax and AlphaZero backends implement the same JSON message format, making them interchangeable from the frontend's perspective.
